This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-03T07:00:26.487Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
assets/
  dot-background.svg
  settings-01.svg
src/
  classes.js
  functions.js
  index.js
  styles.css
index.html
package.json
README.md

================================================================
Repository Files
================================================================

================
File: assets/dot-background.svg
================
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32' width='16' height='16' fill='none'><circle fill='rgb(0 0 0 / 0.2)' id='pattern-circle' cx='10' cy='10' r='1.6257413380501518'></circle></svg>

================
File: assets/settings-01.svg
================
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  viewBox="0 0 24 24"
  fill="none"
>
  <path
    opacity="0.28"
    d="M14.1026 4.417L13.7992 4.11982L13.7992 4.11981C13.1682 3.50174 12.8527 3.1927 12.4903 3.07661C12.1714 2.97446 11.8286 2.97446 11.5097 3.07661C11.1473 3.1927 10.8318 3.50174 10.2008 4.11981L10.2008 4.11982L9.89735 4.417L9.89735 4.41701C9.62451 4.68424 9.48809 4.81786 9.32984 4.91393C9.18951 4.99913 9.03695 5.06232 8.87749 5.1013C8.69764 5.14527 8.5067 5.14725 8.12481 5.15122H8.12481L7.70012 5.15562C6.81685 5.16479 6.37522 5.16937 6.03688 5.34354C5.73918 5.49678 5.49678 5.73918 5.34354 6.03688C5.16937 6.37522 5.16479 6.81685 5.15562 7.70012L5.15122 8.12481V8.12481C5.14725 8.5067 5.14527 8.69764 5.1013 8.87749C5.06232 9.03695 4.99913 9.18951 4.91393 9.32984C4.81786 9.48809 4.68424 9.62451 4.41701 9.89735L4.417 9.89735L4.11982 10.2008L4.11981 10.2008C3.50173 10.8318 3.1927 11.1473 3.07661 11.5097C2.97446 11.8286 2.97446 12.1714 3.07661 12.4903C3.1927 12.8527 3.50174 13.1682 4.11981 13.7992L4.11982 13.7992L4.417 14.1026C4.68424 14.3755 4.81786 14.5119 4.91393 14.6702C4.99913 14.8105 5.06232 14.963 5.1013 15.1225C5.14527 15.3024 5.14725 15.4933 5.15122 15.8752L5.15562 16.2999C5.16479 17.1831 5.16937 17.6248 5.34354 17.9631C5.49678 18.2608 5.73918 18.5032 6.03688 18.6565C6.37522 18.8306 6.81685 18.8352 7.70012 18.8444L8.12481 18.8488C8.5067 18.8527 8.69764 18.8547 8.87749 18.8987C9.03695 18.9377 9.18951 19.0009 9.32984 19.0861C9.48809 19.1821 9.62451 19.3158 9.89735 19.583L10.2008 19.8802L10.2008 19.8802C10.8318 20.4983 11.1473 20.8073 11.5097 20.9234C11.8286 21.0255 12.1714 21.0255 12.4903 20.9234C12.8527 20.8073 13.1682 20.4983 13.7992 19.8802L13.7992 19.8802L14.1026 19.583C14.3755 19.3158 14.5119 19.1821 14.6702 19.0861C14.8105 19.0009 14.963 18.9377 15.1225 18.8987C15.3024 18.8547 15.4933 18.8527 15.8752 18.8488L16.2999 18.8444C17.1831 18.8352 17.6248 18.8306 17.9631 18.6565C18.2608 18.5032 18.5032 18.2608 18.6565 17.9631C18.8306 17.6248 18.8352 17.1831 18.8444 16.2999L18.8488 15.8752C18.8527 15.4933 18.8547 15.3024 18.8987 15.1225C18.9377 14.963 19.0009 14.8105 19.0861 14.6702C19.1821 14.5119 19.3158 14.3755 19.583 14.1026L19.8802 13.7992L19.8802 13.7992C20.4983 13.1682 20.8073 12.8527 20.9234 12.4903C21.0255 12.1714 21.0255 11.8286 20.9234 11.5097C20.8073 11.1473 20.4983 10.8318 19.8802 10.2008L19.8802 10.2008L19.583 9.89735C19.3158 9.62451 19.1821 9.48809 19.0861 9.32984C19.0009 9.18951 18.9377 9.03695 18.8987 8.87749C18.8547 8.69764 18.8527 8.5067 18.8488 8.12481L18.8444 7.70012C18.8352 6.81685 18.8306 6.37522 18.6565 6.03688C18.5032 5.73918 18.2608 5.49678 17.9631 5.34354C17.6248 5.16937 17.1831 5.16479 16.2999 5.15562L15.8752 5.15122C15.4933 5.14725 15.3024 5.14527 15.1225 5.1013C14.963 5.06232 14.8105 4.99913 14.6702 4.91393C14.5119 4.81786 14.3755 4.68424 14.1026 4.417Z"
    fill="currentcolor"
  />
  <path
    d="M10.2007 4.11982C10.8318 3.50174 11.1473 3.1927 11.5097 3.07661C11.8285 2.97446 12.1713 2.97446 12.4902 3.07661C12.8526 3.1927 13.1681 3.50174 13.7992 4.11982L14.1026 4.417C14.3754 4.68424 14.5118 4.81786 14.6701 4.91393C14.8104 4.99913 14.963 5.06232 15.1225 5.1013C15.3023 5.14527 15.4932 5.14725 15.8751 5.15122L16.2998 5.15562C17.1831 5.16479 17.6247 5.16937 17.9631 5.34354C18.2608 5.49678 18.5032 5.73918 18.6564 6.03688C18.8306 6.37522 18.8351 6.81685 18.8443 7.70012L18.8487 8.12481C18.8527 8.5067 18.8547 8.69764 18.8986 8.87749C18.9376 9.03695 19.0008 9.18951 19.086 9.32984C19.1821 9.48809 19.3157 9.62451 19.5829 9.89735L19.8801 10.2008C20.4982 10.8318 20.8072 11.1473 20.9233 11.5097C21.0255 11.8286 21.0255 12.1714 20.9233 12.4903C20.8072 12.8527 20.4982 13.1682 19.8801 13.7992L19.5829 14.1026C19.3157 14.3755 19.1821 14.5119 19.086 14.6702C19.0008 14.8105 18.9376 14.963 18.8986 15.1225C18.8547 15.3024 18.8527 15.4933 18.8487 15.8752L18.8443 16.2999C18.8351 17.1831 18.8306 17.6248 18.6564 17.9631C18.5032 18.2608 18.2608 18.5032 17.9631 18.6565C17.6247 18.8306 17.1831 18.8352 16.2998 18.8444L15.8751 18.8488C15.4932 18.8527 15.3023 18.8547 15.1225 18.8987C14.963 18.9377 14.8104 19.0009 14.6701 19.0861C14.5118 19.1821 14.3754 19.3158 14.1026 19.583L13.7992 19.8802C13.1681 20.4983 12.8526 20.8073 12.4902 20.9234C12.1713 21.0255 11.8285 21.0255 11.5097 20.9234C11.1473 20.8073 10.8318 20.4983 10.2007 19.8802L9.89729 19.583C9.62445 19.3158 9.48803 19.1821 9.32978 19.0861C9.18945 19.0009 9.03689 18.9377 8.87742 18.8987C8.69758 18.8547 8.50664 18.8527 8.12475 18.8488L7.70006 18.8444C6.81679 18.8352 6.37516 18.8306 6.03682 18.6565C5.73912 18.5032 5.49672 18.2608 5.34348 17.9631C5.16931 17.6248 5.16473 17.1831 5.15556 16.2999L5.15115 15.8752C5.14719 15.4933 5.14521 15.3024 5.10124 15.1225C5.06226 14.963 4.99907 14.8105 4.91387 14.6702C4.81779 14.5119 4.68418 14.3755 4.41694 14.1026L4.11976 13.7992C3.50168 13.1682 3.19264 12.8527 3.07655 12.4903C2.9744 12.1714 2.9744 11.8286 3.07655 11.5097C3.19264 11.1473 3.50168 10.8318 4.11976 10.2008L4.41694 9.89735C4.68418 9.62451 4.81779 9.48809 4.91387 9.32984C4.99907 9.18951 5.06226 9.03695 5.10124 8.87749C5.14521 8.69764 5.14719 8.5067 5.15115 8.12481L5.15556 7.70012C5.16473 6.81685 5.16931 6.37522 5.34348 6.03688C5.49672 5.73918 5.73912 5.49678 6.03682 5.34354C6.37516 5.16937 6.81679 5.16479 7.70006 5.15562L8.12475 5.15122C8.50664 5.14725 8.69758 5.14527 8.87742 5.1013C9.03689 5.06232 9.18945 4.99913 9.32978 4.91393C9.48803 4.81786 9.62445 4.68424 9.89729 4.417L10.2007 4.11982Z"
    stroke="currentcolor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
  <path
    d="M10.991 12C10.991 11.4477 11.4479 11 12.0001 11C12.5524 11 13.0093 11.4477 13.0093 12C13.0093 12.5523 12.5524 13 12.0001 13C11.4479 13 10.991 12.5523 10.991 12Z"
    stroke="currentcolor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
  />
</svg>

================
File: src/classes.js
================
import { Graphics } from 'pixi.js';

import { angle_between_vectors, average_angle_from_list, rotate_vector } from './functions.js'


export class Constants {
	constructor() {
		this.DAMPINGz = .7;
		this.DAMPING = .8;
		this.DRAG = .995;
		this.GRAVITY = 980;
		this.FIXED_TIME_STEP = 1/60;
        this.DEFAULT_COLUMNS = 60;
        this.DEFAULT_ROWS = 30;
        this.DEFAULT_PINS = 7;
	}
}

export class Globals {
	constructor() {
        this.vertex_holder = [];
        this.line_holder = new Set();
        this.particle_holder = [];
        this.all_lines_graphics = new Graphics();
        this.particle_container;
        this.render_offset_x = 100;
        this.render_offset_y = 100;
        this.render_scale = 1

        this.cut_mode = false;
        this.drag_mode = false;
        this.still_dragging = false;
        this.drag_snap_distance = 10;;
        this.chosen_dragging_vertex = null;
        this.line_length;
        this.mouse_position = {x:0, y:0};

        this.tearing = true;
        this.tearing_ratio = 10;

        this.grav_modifier = 1;

        this.constraint_itterations = 8;

        this.primary_button = 0;
        this.grav_button = 1;
        this.cut_button = 2;

        this.edit_mode = true;
        this.primary_button_clicked = false;
        this.shape_vertices = []
        this.circle_texture ;
        this.polygon_graphics = new Graphics();

        this.closest_vertex = null;
        this.shapes_holder = [];
        this.app;


        this.bounding_box_graphics = new Graphics();

        this.debug_graphics_layer_1 = new Graphics();
        this.debug_graphics_layer_2 = new Graphics();
        this.debug_graphics_layer_3 = new Graphics();
        this.imaginary_points = [];

        this.raycast_line_segments = [];
        this.edge_normals = [];


	}
}

export class Elements {
	constructor() {
        this.cloth_sim_holder = document.getElementById("cloth-sim-holder");
        this.tearing_checkbox = document.getElementById("tearing-checkbox");
        this.build_button = document.getElementById("build-button");
        this.menu_holder = document.getElementById("menu-holder");
        this.up_arrow = document.getElementById("up-arrow");
        this.down_arrow = document.getElementById("down-arrow");
        this.fps_counter;
	}
}

export class Shape {
    constructor(surface_vertice_holder, inner_vertice_holder, frame_vertice_holder, spring_holder, frame_spring_holder) {
        this.surface_vertice_holder = surface_vertice_holder;
        this.inner_vertice_holder = inner_vertice_holder;
        this.frame_vertice_holder = frame_vertice_holder;

        this.spring_holder = spring_holder;
        this.frame_spring_holder = frame_spring_holder;

        this.particle_holder = [];
        this.particle_container;


        this.bounding_box = {left:0, right:0, top:0, bottom: 0, intersecting: false, intersecting_shapes_list: []}
        this.color = 0x66CCFF;
    }
    
    update_vertices(globals, constants, dt) {
        for (let vertex of this.surface_vertice_holder) {

            const vx = (vertex.x - vertex.prev_x) * constants.DRAG;
            const vy = (vertex.y - vertex.prev_y) * constants.DRAG + constants.GRAVITY * globals.grav_modifier * dt * dt;
    
            vertex.prev_x = vertex.x;
            vertex.prev_y = vertex.y;


            if (vertex.y > 600) {
                vertex.touching = true;
            }

            if (!vertex.grabbed) {
                if (vertex.touching) {
                    vertex.x += vx*.75;
                    vertex.y += vy*.75;

                } else {
                    vertex.x += vx;
                    vertex.y += vy;
                }
            } else {
                vertex.x = globals.mouse_position.x/globals.render_scale;
                vertex.y = globals.mouse_position.y/globals.render_scale;
    
            }
            if (vertex.y > 600) {
                vertex.y = 600;
            }
        }

        for (let vertex of this.inner_vertice_holder) {
            const vx = (vertex.x - vertex.prev_x) * constants.DRAG;
            const vy = (vertex.y - vertex.prev_y) * constants.DRAG + constants.GRAVITY * globals.grav_modifier * dt * dt;
    
            vertex.prev_x = vertex.x;
            vertex.prev_y = vertex.y;
            if (!vertex.grabbed) {
                vertex.x += vx;
                vertex.y += vy;
            } else {
                vertex.x = globals.mouse_position.x/globals.render_scale;
                vertex.y = globals.mouse_position.y/globals.render_scale;
    
            }
            if (vertex.y > 600) {
                vertex.y = 600;
            }
        }
    }

    update_springs(globals, constants) {
        for (let f = 0; f < 1; f++) {
            for (let spring of this.spring_holder) {
                const vertex_1 = spring.vertex_1;
                const vertice_2 = spring.vertex_2;
    
                const distance_x = vertice_2.x - vertex_1.x;
                const distance_y = vertice_2.y - vertex_1.y;
                const distance = Math.sqrt(distance_x**2 + distance_y**2);
                const difference = (spring.length - distance) / distance;
    
                const correction_x = distance_x * difference * 0.5;
                const correction_y = distance_y * difference * 0.5;
    
                if (!vertex_1.grabbed) {
                    vertex_1.x -= correction_x * (1 - constants.DAMPING);
                    vertex_1.y -= correction_y * (1 - constants.DAMPING);
                }
                if (!vertice_2.grabbed) {
                    vertice_2.x += correction_x * (1 - constants.DAMPING);
                    vertice_2.y += correction_y * (1 - constants.DAMPING);
                }
            }
        }
    }

    calculate_center() {
        if ( this.surface_vertice_holder.length > 0 ) {
            var x_sum = 0;
            var y_sum = 0;
    
            for (let vertex of this.surface_vertice_holder) {
                x_sum += vertex.x;
                y_sum += vertex.y;
            }
            var x_average = x_sum/this.surface_vertice_holder.length;
            var y_average = y_sum/this.surface_vertice_holder.length;
            return {x:x_average, y:y_average}

        } else {
            return {x:0, y:0}
        }
    }

    calculate_average_angle_to_frame(center) {
        var angle_list = [];
        for (let i = 0; i < this.surface_vertice_holder.length; i++) {
            const surface_vertex = this.surface_vertice_holder[i];
            const frame_vertex = this.frame_vertice_holder[i];

            const surface_vertex_relative_to_center = {x:surface_vertex.x - center.x, y:surface_vertex.y - center.y};
            const frame_vertex_relative_to_center = {x:frame_vertex.x - center.x, y:frame_vertex.y - center.y};

            const angle = angle_between_vectors(surface_vertex_relative_to_center, frame_vertex_relative_to_center)
            
            angle_list.push(angle);
        }

        let average_angle = average_angle_from_list(angle_list);
        return average_angle;
    }

    update_frame_transform() {

        var center = this.calculate_center();

        for (let frame_vertex of this.frame_vertice_holder) {

            frame_vertex.x = center.x + frame_vertex.offset_x;
            frame_vertex.y = center.y + frame_vertex.offset_y;
        }


        var average_angle = this.calculate_average_angle_to_frame(center);
        //console.log("average_angle:", average_angle);

        for (let frame_vertex of this.frame_vertice_holder) {

            let updated_frame_offset = rotate_vector({x: frame_vertex.offset_x, y: frame_vertex.offset_y}, -average_angle);

            frame_vertex.x = center.x + updated_frame_offset.x;
            frame_vertex.y = center.y + updated_frame_offset.y;

        }

    }

    update_frame_springs(constants) {
        for (let f = 0; f < 1; f++) {
            for (let frame_spring of this.frame_spring_holder) {
                const frame_vertex = frame_spring.frame_vertex;
                const surface_vertex = frame_spring.surface_vertex;

                //console.log("frame_vertex:", frame_vertex);
                //console.log("surface_vertex:", surface_vertex);
    
                const distance_x = frame_vertex.x - surface_vertex.x;
                const distance_y = frame_vertex.y - surface_vertex.y;
    
                if (!surface_vertex.grabbed) {
                    //console.log("distance_x:", distance_x);
                    surface_vertex.x += distance_x * (1 - constants.DAMPING);
                    surface_vertex.y += distance_y * (1 - constants.DAMPING);
                }
            }
        }
    }

    update_particles(globals) {
        var combined_vertice_holder = this.surface_vertice_holder.concat(this.inner_vertice_holder);
        for (let i = 0; i < combined_vertice_holder.length; i++) {
            const vertex = combined_vertice_holder[i];
            const particle = this.particle_holder[i];


            particle.position.set(vertex.x*globals.render_scale, vertex.y*globals.render_scale);
            if (vertex.hovered == true) {
                particle.position.set(vertex.x*globals.render_scale, vertex.y*globals.render_scale - 2);
            }

        }

    }

    update_bounding_box() {
        const first_vertex = this.surface_vertice_holder[0];
        this.bounding_box = {left:first_vertex.x, right:first_vertex.x, top:first_vertex.y, bottom: first_vertex.y}
        for (let i = 1; i < this.surface_vertice_holder.length; i++) {
            const vertex = this.surface_vertice_holder[i];

            this.bounding_box.left = Math.min(this.bounding_box.left, vertex.x);
            this.bounding_box.right = Math.max(this.bounding_box.right, vertex.x);
            this.bounding_box.top = Math.min(this.bounding_box.top, vertex.y);
            this.bounding_box.bottom = Math.max(this.bounding_box.bottom, vertex.y);

        }
    }

    clear_touching() {
        for (let i = 0; i < this.surface_vertice_holder.length; i++) {
            const vertex = this.surface_vertice_holder[i];
            vertex.touching = false;
        }
    }
}

================
File: src/functions.js
================
import { Container, Graphics, Sprite } from "pixi.js";
import { Constants, Elements, Globals, Shape } from "./classes.js";

function mod(n, m) {
  return ((n % m) + m) % m;
}

export function create_fps_counter() {
  var script = document.createElement("script");
  script.onload = function () {
    var stats = new Stats();
    document.body.appendChild(stats.dom);
    stats.dom.id = "fps-counter-element";
    requestAnimationFrame(function loop() {
      stats.update();
      requestAnimationFrame(loop);
    });
  };
  script.src = "https://mrdoob.github.io/stats.js/build/stats.min.js";
  document.head.appendChild(script);
  //globals.loading_fps_counter
}

export function draw_graphics(globals) {
  globals.all_lines_graphics.clear();
  globals.polygon_graphics.clear();
  globals.bounding_box_graphics.clear();

  for (let shape of globals.shapes_holder) {
    let color_to_use = shape.bounding_box.intersecting ? 0xffff00 : shape.color;

    globals.polygon_graphics.beginFill(color_to_use);
    globals.polygon_graphics.lineStyle(4, 0xff0000);
    var adjusted_vertices = [];
    for (let vertex of shape.surface_vertice_holder) {
      const adjusted_vertex = {
        x: vertex.x * globals.render_scale,
        y: vertex.y * globals.render_scale,
      };
      adjusted_vertices.push(adjusted_vertex);
    }
    globals.polygon_graphics.drawPolygon(adjusted_vertices);
    globals.polygon_graphics.endFill();

    globals.all_lines_graphics.beginPath();

    for (let spring of shape.spring_holder) {
      const vertex_1 = spring.vertex_1;
      const vertex_2 = spring.vertex_2;

      globals.all_lines_graphics.moveTo(
        vertex_1.x * globals.render_scale,
        vertex_1.y * globals.render_scale,
      );
      globals.all_lines_graphics.lineTo(
        vertex_2.x * globals.render_scale,
        vertex_2.y * globals.render_scale,
      );
    }

    if (false) {
      for (let i = 0; i < shape.frame_vertice_holder.length; i++) {
        var current_frame_vertex = shape.frame_vertice_holder[i];
        let prev_frame_vertex_index = i - 1;
        if (prev_frame_vertex_index < 0) {
          prev_frame_vertex_index = shape.frame_vertice_holder.length - 1;
        }
        var prev_frame_vertex =
          shape.frame_vertice_holder[prev_frame_vertex_index];

        globals.all_lines_graphics.moveTo(
          prev_frame_vertex.x * globals.render_scale,
          prev_frame_vertex.y * globals.render_scale,
        );
        globals.all_lines_graphics.lineTo(
          current_frame_vertex.x * globals.render_scale,
          current_frame_vertex.y * globals.render_scale,
        );
      }

      for (let frame_spring of shape.frame_spring_holder) {
        const frame_vertex = frame_spring.frame_vertex;
        const surface_vertex = frame_spring.surface_vertex;

        globals.all_lines_graphics.moveTo(
          frame_vertex.x * globals.render_scale,
          frame_vertex.y * globals.render_scale,
        );
        globals.all_lines_graphics.lineTo(
          surface_vertex.x * globals.render_scale,
          surface_vertex.y * globals.render_scale,
        );
      }
    }

    globals.all_lines_graphics.stroke();

    globals.bounding_box_graphics.beginPath();
    const padding = 0;

    const left = shape.bounding_box.left * globals.render_scale - padding;
    const right = shape.bounding_box.right * globals.render_scale + padding;
    const top = shape.bounding_box.top * globals.render_scale - padding;
    const bottom = shape.bounding_box.bottom * globals.render_scale + padding;

    globals.bounding_box_graphics.moveTo(left, top);
    globals.bounding_box_graphics.lineTo(right, top);

    globals.bounding_box_graphics.moveTo(right, top);
    globals.bounding_box_graphics.lineTo(right, bottom);

    globals.bounding_box_graphics.moveTo(right, bottom);
    globals.bounding_box_graphics.lineTo(left, bottom);

    globals.bounding_box_graphics.moveTo(left, bottom);
    globals.bounding_box_graphics.lineTo(left, top);

    globals.bounding_box_graphics.stroke();
  }

  for (let shape of globals.shapes_holder) {
    shape.update_particles(globals);
  }
}

export function hide_element(element) {
  element.classList.add("hidden");
}

export function show_element(element) {
  element.classList.remove("hidden");
}

export function angle_between_vectors(vector_1, vector_2) {
  let angle_a = Math.atan2(vector_1.y, vector_1.x);
  let angle_b = Math.atan2(vector_2.y, vector_2.x);

  let angle_difference = angle_b - angle_a;

  return angle_difference;
}

export function average_angle_from_list(angle_list) {
  let sum_sin = 0;
  let sum_cos = 0;

  for (let i = 0; i < angle_list.length; i++) {
    sum_sin += Math.sin(angle_list[i]);
    sum_cos += Math.cos(angle_list[i]);
  }

  // Compute the average angle using atan2
  let average = Math.atan2(sum_sin, sum_cos);

  return average;
}

export function rotate_vector(vector, angle) {
  const rotated_x = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
  const rotated_y = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);

  return { x: rotated_x, y: rotated_y };
}

export function point_in_polygon(vertex, shape) {
  let count = 0;
  const n_vertices = shape.surface_vertice_holder.length;

  // Loop through each edge of the polygon
  for (let i = 0; i < n_vertices; i++) {
    let line_end_1 = shape.surface_vertice_holder[i];
    let line_end_2 = shape.surface_vertice_holder[(i + 1) % n_vertices];

    if (edge_intersects_horizontal_ray(vertex, line_end_1, line_end_2)) {
      count++;
    }
  }
  // If count is odd, point is inside the polygon
  return count % 2 === 1;
}

function edge_intersects_horizontal_ray(vertex, line_end_1, line_end_2) {
  // First, check if the point's y-coordinate is within the vertical range of the edge
  // The way pixijs works is that y is greater further down, so the larger value is the bottom
  const top_line_end_y = Math.min(line_end_1.y, line_end_2.y);
  const bottom_line_end_y = Math.max(line_end_1.y, line_end_2.y);

  if (vertex.y < top_line_end_y || vertex.y > bottom_line_end_y) {
    return false; // Edge is not crossed by the horizontal line at point_y
  }

  // Check if the edge is horizontal
  if (line_end_1.y === line_end_2.y) {
    // Check if the point is on the horizontal edge
    if (line_end_1.y === vertex.y) {
      //point is vertically aligned with the horizontal edge
      const left_line_end =
        line_end_1.x < line_end_2.x ? line_end_1 : line_end_2;
      const right_line_end =
        line_end_1.x > line_end_2.x ? line_end_1 : line_end_2;

      if (vertex.x > left_line_end.x && vertex.x < right_line_end.x) {
        //vertex.x is between the line ends
        return true;
      }
    }
    return false; // Horizontal edge does not intersect the ray
  }

  // Compute the x-coordinate of the intersection point, x = (y+b)/m
  const line_change_in_x = line_end_2.x - line_end_1.x;
  const line_change_in_y = line_end_2.y - line_end_1.y;
  const m = line_change_in_y / line_change_in_x;
  //we'll pick line_end_1 to be the origin, so b = 0
  //That means the vertical level where we do our check needs to be shifted so that it's in terms of our new origin but still the same relative to our line
  const y = vertex.y - line_end_1.y;

  //After finding the x-coordinate of the intersection point we need to add the x value fo line_end_1 to it to put it back into global coordinates
  let intersect_x = line_end_1.x + y / m;

  //let intersect_x = line_end_1.x + ((vertex.y - line_end_1.y) * line_change_in_x) / line_change_in_y;

  // Check if the intersection point is to the right of vertex.x
  return intersect_x > vertex.x;
}

export function closest_edge(globals, vertex, shape) {
  let nearest_edge = null;
  let nearest_normal = null;
  let vertex_direction_normal_dot_product = 0;
  let close_candidates = [];
  let nearest_edge_distance = 99999999999999;

  const intersecting_edges = [];

  const direction_vector_distance = get_distance_between_points(vertex, {
    x: vertex.prev_x,
    y: vertex.prev_y,
  });
  const direction_vector = {
    x: (vertex.x - vertex.prev_x) / direction_vector_distance,
    y: (vertex.y - vertex.prev_y) / direction_vector_distance,
  };

  const exageration_scale = 22.5;
  const exagerated_prev_pos_vertex = {
    x: (vertex.prev_x - vertex.x) * exageration_scale + vertex.x,
    y: (vertex.prev_y - vertex.y) * exageration_scale + vertex.y,
  };

  const exagerated_vertex = {
    x: (vertex.prev_x - vertex.x) * -exageration_scale + vertex.x,
    y: (vertex.prev_y - vertex.y) * -exageration_scale + vertex.y,
  };

  const n_vertices = shape.surface_vertice_holder.length;
  // Loop through each edge of the polygon
  for (let i = 0; i < n_vertices; i++) {
    const edge_point_a = shape.surface_vertice_holder[i];
    const edge_point_b = shape.surface_vertice_holder[(i + 1) % n_vertices];

    const edge_change_in_x = edge_point_a.x - edge_point_b.x;
    const edge_change_in_y = edge_point_a.y - edge_point_b.y;
    const edge_distance = get_distance_between_points(
      edge_point_a,
      edge_point_b,
    );
    const edge_normal = {
      x: -edge_change_in_y / edge_distance,
      y: edge_change_in_x / edge_distance,
    };
    const edge_centerpoint = {
      x: (edge_point_a.x + edge_point_b.x) / 2,
      y: (edge_point_a.y + edge_point_b.y) / 2,
    };
    globals.edge_normals.push([edge_centerpoint, edge_normal]);

    // Return true if line segments AB and CD intersect
    //intersect(vertex,exagerated_prev_pos_vertex,edge_point_a,edge_point_b)
    globals.raycast_line_segments.push([
      exagerated_vertex,
      exagerated_prev_pos_vertex,
    ]);
    //console.log("vertex:", vertex)
    //console.log("exagerated_prev_pos_vertex:", exagerated_prev_pos_vertex)

    //const test_intersection = intersection_point( {x:0, y:0}, {x:2, y:2}, {x:0, y:2}, {x:2, y:0} )
    //console.log("test_intersection:", test_intersection)

    //const intersection = intersection_point(exagerated_vertex,exagerated_prev_pos_vertex, edge_point_a,edge_point_b)
    //console.log("intersection:", intersection)

    /*
        if ( intersection != null) {
            //const intersection_point = get_distance_between_points(vertex, intersection)
            const distance = get_distance_between_points(vertex, intersection);
            if (distance < nearest_edge_distance) {
                nearest_edge = {a: edge_point_a, b: edge_point_b}
                nearest_edge_distance = distance;
            }
        }
        // */
    // /*
    // Compute the vector from A to B
    const ab_vector = {
      x: edge_point_b.x - edge_point_a.x,
      y: edge_point_b.y - edge_point_a.y,
    };

    // Compute the vector from A to P
    const ap_vector = {
      x: vertex.x - edge_point_a.x,
      y: vertex.y - edge_point_a.y,
    };

    const t = dot(ap_vector, ab_vector) / dot(ab_vector, ab_vector);
    const clamped_t = Math.min(1, Math.max(0, t));

    const vertex_projected_onto_edge = {
      x: edge_point_a.x + clamped_t * ab_vector.x,
      y: edge_point_a.y + clamped_t * ab_vector.y,
    };

    const distance = get_distance_between_points(
      vertex,
      vertex_projected_onto_edge,
    );

    if (distance < nearest_edge_distance) {
      const difference_from_next_closest = Math.abs(
        distance - nearest_edge_distance,
      );
      if (
        difference_from_next_closest < 0.1 &&
        difference_from_next_closest > 0
      ) {
        const new_vertex_direction_normal_dot_product =
          direction_vector.x * direction_vector.x +
          edge_normal.y * edge_normal.y;

        globals.debug_graphics_layer_3.beginFill(0xff00ff); // Purple color

        globals.debug_graphics_layer_3.moveTo(edge_point_a.x, edge_point_a.y);
        globals.debug_graphics_layer_3.lineTo(edge_point_b.x, edge_point_b.y);

        globals.debug_graphics_layer_3.moveTo(
          nearest_edge.a.x,
          nearest_edge.a.y,
        );
        globals.debug_graphics_layer_3.lineTo(
          nearest_edge.b.x,
          nearest_edge.b.y,
        );

        globals.debug_graphics_layer_3.endFill();

        if (
          Math.abs(new_vertex_direction_normal_dot_product) >
          Math.abs(vertex_direction_normal_dot_product)
        ) {
          console.log(
            "new_vertex_direction_normal_dot_product:",
            new_vertex_direction_normal_dot_product,
          );
          console.log(
            "vertex_direction_normal_dot_product:",
            vertex_direction_normal_dot_product,
          );

          //globals.debug_graphics_layer_3.clear();  // Clear previous debug drawings

          /*
                    console.log("vertex:", "vertex.x:", vertex.x, "vertex.x:", vertex.y)
                    console.log("older:", "a.x:", edge_point_a.x, "a.y:", edge_point_a.y, "b.x:", edge_point_b.x, "b.y:", edge_point_b.y)
                    console.log("newer:", "a.x:", nearest_edge.a.x, "a.y:", nearest_edge.a.y, "b.x:", nearest_edge.b.x, "b.y:", nearest_edge.b.y)

                    console.log("direction_vector:", direction_vector)
                    console.log("normal_vector_of_older:", normal_vector_of_older)
                    console.log("normal_vector_of_newer:", normal_vector_of_newer)

                    console.log("Diff:", Math.abs( Math.abs(direction_vector_normal_vector_of_newer_dot_product) - Math.abs(direction_vector_normal_vector_of_older_dot_product) ) )

                    console.log("direction_vector_normal_vector_of_older_dot_product:", direction_vector_normal_vector_of_older_dot_product)
                    console.log("direction_vector_normal_vector_of_newer_dot_product:", direction_vector_normal_vector_of_newer_dot_product)
                    console.log("###")
                    */

          nearest_edge = { a: edge_point_a, b: edge_point_b };
          nearest_edge_distance = distance;
          nearest_normal = edge_normal;
          vertex_direction_normal_dot_product =
            new_vertex_direction_normal_dot_product;
        }
      } else {
        nearest_edge = { a: edge_point_a, b: edge_point_b };
        nearest_edge_distance = distance;
        nearest_normal = edge_normal;
        vertex_direction_normal_dot_product =
          direction_vector.x * direction_vector.x +
          edge_normal.y * edge_normal.y;
      }
    }
    //*/
  }
  return nearest_edge;
}

export function closest_edge_with_depth(globals, vertex, shape) {
  let nearest_edge = null;
  let nearest_edge_distance = 99999999999999;

  const n_vertices = shape.surface_vertice_holder.length;
  // Loop through each edge of the polygon
  for (let i = 0; i < n_vertices; i++) {
    const edge_point_a = shape.surface_vertice_holder[i];
    const edge_point_b = shape.surface_vertice_holder[(i + 1) % n_vertices];

    // Compute the vector from A to B
    const ab_vector = {
      x: edge_point_b.x - edge_point_a.x,
      y: edge_point_b.y - edge_point_a.y,
    };

    // Compute the vector from A to P
    const ap_vector = {
      x: vertex.x - edge_point_a.x,
      y: vertex.y - edge_point_a.y,
    };

    const t = dot(ap_vector, ab_vector) / dot(ab_vector, ab_vector);
    const clamped_t = Math.min(1, Math.max(0, t));

    const vertex_projected_onto_edge = {
      x: edge_point_a.x + clamped_t * ab_vector.x,
      y: edge_point_a.y + clamped_t * ab_vector.y,
    };

    const distance = get_distance_between_points(
      vertex,
      vertex_projected_onto_edge,
    );

    if (distance < nearest_edge_distance) {
      nearest_edge = { a: edge_point_a, b: edge_point_b };
      nearest_edge_distance = distance;
    }
  }
  return [nearest_edge, nearest_edge_distance];
}

export function top_two_closest_edges(globals, vertex, shape) {
  let nearest_edge = null;
  let second_nearest_edge = null;
  let nearest_edge_distance = 99999999999999;

  const n_vertices = shape.surface_vertice_holder.length;
  // Loop through each edge of the polygon
  for (let i = 0; i < n_vertices; i++) {
    const edge_point_a = shape.surface_vertice_holder[i];
    const edge_point_b = shape.surface_vertice_holder[(i + 1) % n_vertices];

    // Compute the vector from A to B
    const ab_vector = {
      x: edge_point_b.x - edge_point_a.x,
      y: edge_point_b.y - edge_point_a.y,
    };

    // Compute the vector from A to P
    const ap_vector = {
      x: vertex.x - edge_point_a.x,
      y: vertex.y - edge_point_a.y,
    };

    const t = dot(ap_vector, ab_vector) / dot(ab_vector, ab_vector);
    const clamped_t = Math.min(1, Math.max(0, t));

    const vertex_projected_onto_edge = {
      x: edge_point_a.x + clamped_t * ab_vector.x,
      y: edge_point_a.y + clamped_t * ab_vector.y,
    };

    const distance = get_distance_between_points(
      vertex,
      vertex_projected_onto_edge,
    );

    if (distance < nearest_edge_distance) {
      second_nearest_edge = nearest_edge;
      nearest_edge = { a: edge_point_a, b: edge_point_b };
      nearest_edge_distance = distance;
    } else if (second_nearest_edge == null) {
      second_nearest_edge = { a: edge_point_a, b: edge_point_b };
    }
  }
  return [nearest_edge, second_nearest_edge];
}

export function edges_sorted_by_proximity(globals, vertex, shape) {
  const edges = [];
  const n_vertices = shape.surface_vertice_holder.length;
  // Loop through each edge of the polygon
  for (let i = 0; i < n_vertices; i++) {
    const edge_point_a = shape.surface_vertice_holder[i];
    const edge_point_b = shape.surface_vertice_holder[(i + 1) % n_vertices];

    const ab_vector = {
      x: edge_point_b.x - edge_point_a.x,
      y: edge_point_b.y - edge_point_a.y,
    };

    // Compute the vector from A to P
    const ap_vector = {
      x: vertex.x - edge_point_a.x,
      y: vertex.y - edge_point_a.y,
    };

    const t = dot(ap_vector, ab_vector) / dot(ab_vector, ab_vector);
    const clamped_t = Math.min(1, Math.max(0, t));

    const vertex_projected_onto_edge = {
      x: edge_point_a.x + clamped_t * ab_vector.x,
      y: edge_point_a.y + clamped_t * ab_vector.y,
    };

    const distance = get_distance_between_points(
      vertex,
      vertex_projected_onto_edge,
    );
    edges.push([distance, { a: edge_point_a, b: edge_point_b }]);
  }
  edges.sort((a, b) => a[0] - b[0]);
  return edges;
}

function dot(vector_a, vector_b) {
  return vector_a.x * vector_b.x + vector_a.y * vector_b.y;
}

export function get_distance_between_points(point_a, point_b) {
  let dx = point_b.x - point_a.x;
  let dy = point_b.y - point_a.y;
  let distance = Math.hypot(dx, dy);
  return distance;
}

export function resolve_collision(globals, point, edge) {
  // Edge points
  let edge_point_a = edge.a;
  let edge_point_b = edge.b;

  // Compute the vector from A to B
  const ab_vector = {
    x: edge_point_b.x - edge_point_a.x,
    y: edge_point_b.y - edge_point_a.y,
  };

  // Compute the vector from A to P
  const ap_vector = {
    x: point.x - edge_point_a.x,
    y: point.y - edge_point_a.y,
  };

  const t = dot(ap_vector, ab_vector) / dot(ab_vector, ab_vector);
  //clamp t between 0 and 1
  const clamped_t = Math.max(0, Math.min(1, t));

  const vertex_projected_onto_edge = {
    x: edge_point_a.x + t * ab_vector.x,
    y: edge_point_a.y + t * ab_vector.y,
  };

  const distance = get_distance_between_points(
    point,
    vertex_projected_onto_edge,
  );
  const penetration_vector = {
    x: point.x - vertex_projected_onto_edge.x,
    y: point.y - vertex_projected_onto_edge.y,
  };

  // Weighting factor alpha
  let alpha = 1 - clamped_t;

  let mTotal = 3;

  // Resolve penetration
  //Multipling by .999 so that they're just barely not overlapping
  const overlap_stopping_factor = 1;
  let point_movement_factor = 2 / mTotal;
  point.x -=
    penetration_vector.x * point_movement_factor * overlap_stopping_factor;
  point.y -=
    penetration_vector.y * point_movement_factor * overlap_stopping_factor;

  let edge_adjustment_x = penetration_vector.x * (1 / mTotal);
  let edge_adjustment_y = penetration_vector.y * (1 / mTotal);

  edge_point_a.x += edge_adjustment_x * alpha * overlap_stopping_factor;
  edge_point_a.y += edge_adjustment_y * alpha * overlap_stopping_factor;

  edge_point_b.x += edge_adjustment_x * (1 - alpha) * overlap_stopping_factor;
  edge_point_b.y += edge_adjustment_y * (1 - alpha) * overlap_stopping_factor;

  // Make imaginary point
  const imaginary_point = {
    x: edge_point_a.x * alpha + edge_point_b.x * (1 - alpha),
    y: edge_point_a.y * alpha + edge_point_b.y * (1 - alpha),

    prev_x: edge_point_a.prev_x * alpha + edge_point_b.prev_x * (1 - alpha),
    prev_y: edge_point_a.prev_y * alpha + edge_point_b.prev_y * (1 - alpha),

    mass: (edge_point_a.mass = edge_point_b.mass),
  };
  globals.imaginary_points.push(imaginary_point);

  //New stuff
  // Calculate the distance between the centers of the balls
  const dx = imaginary_point.x - point.x;
  const dy = imaginary_point.y - point.y;
  const collision_distance = Math.sqrt(dx * dx + dy * dy);

  // Calculate the collision normal vector
  const normal_x = dx / collision_distance;
  const normal_y = dy / collision_distance;

  // Calculate the relative velocity vector
  const point_vx = point.x - point.prev_x;
  const point_vy = point.y - point.prev_y;
  const imaginary_point_vx = imaginary_point.x - imaginary_point.prev_x;
  const imaginary_point_vy = imaginary_point.y - imaginary_point.prev_y;

  const relative_velocity_x = imaginary_point_vx - point_vx;
  const relative_velocity_y = imaginary_point_vy - point_vy;

  // Calculate the dot product of the relative velocity and normal vectors
  const dot_product =
    relative_velocity_x * normal_x + relative_velocity_y * normal_y;

  // Check if balls are moving towards each other
  if (dot_product > 0) {
    // Calculate the impulse
    const impulse = (2 * dot_product) / (point.mass + imaginary_point.mass);

    // Update the velocities of the balls
    //point.prev_x = (point.x - point_vx) + ((impulse * imaginary_point.mass * normal_x) / point.mass);
    //point.prev_y = (point.y - point_vy) + ((impulse * imaginary_point.mass * normal_y) / point.mass);

    //point.vx += (impulse * imaginary_point.mass * normal_x) / point.mass;
    //point.vy += (impulse * imaginary_point.mass * normal_y) / point.mass;

    imaginary_point.prev_x =
      imaginary_point.x - imaginary_point_vx - impulse * normal_x;
    imaginary_point.prev_y =
      imaginary_point.y - imaginary_point_vy - impulse * normal_y;

    //imaginary_point.vx -= impulse * normal_x;
    //imaginary_point.vy -= impulse * normal_y;
    //edge_point_a.prev_x = imaginary_point.prev_x
    //edge_point_a.prev_y = imaginary_point.prev_y

    //edge_point_b.prev_x = imaginary_point.prev_x
    //edge_point_b.prev_y = imaginary_point.prev_y
  }
}

export function createCircleTexture(app, radius) {
  const graphics = new Graphics();
  graphics.circle(0, 0, radius);
  graphics.fill(0x000000);
  return app.renderer.generateTexture(graphics);
}

export function set_render_offsets_and_scale(globals) {
  if (window.innerWidth < 1040) {
    globals.render_scale = (window.innerWidth - 40) / 1000;
  } else {
    globals.render_scale = 1;
  }
}

function ccw(A, B, C) {
  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
}

// Return true if line segments AB and CD intersect
export function intersect(A, B, C, D) {
  return ccw(A, C, D) != ccw(B, C, D) && ccw(A, B, C) != ccw(A, B, D);
}

function intersection_point(A, B, C, D) {
  // Check if lines are parallel
  const denominator = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);
  if (denominator === 0) {
    return null; // Lines are parallel
  }

  // Calculate intersection point
  const ua =
    ((D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x)) / denominator;
  const ub =
    ((B.x - A.x) * (A.y - C.y) - (B.y - A.y) * (A.x - C.x)) / denominator;

  // Check if intersection point is within both line segments
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return {
      x: A.x + ua * (B.x - A.x),
      y: A.y + ua * (B.y - A.y),
    };
  }

  return null; // Lines don't intersect within the segments
}

export function find_closest_vertex(globals) {
  var shortest_distance = 9999999999999;
  globals.closest_vertex = { vertex: null, distance: null };
  for (let shape of globals.shapes_holder) {
    for (let vertex of shape.surface_vertice_holder.concat(
      shape.inner_vertice_holder,
    )) {
      const distance_to_mouse_x =
        globals.mouse_position.x / globals.render_scale - vertex.x;
      const distance_to_mouse_y =
        globals.mouse_position.y / globals.render_scale - vertex.y;
      const distance_to_mouse_squared =
        distance_to_mouse_x ** 2 + distance_to_mouse_y ** 2;
      if (distance_to_mouse_squared < shortest_distance) {
        shortest_distance = distance_to_mouse_squared;
        globals.closest_vertex = {
          vertex: vertex,
          distance: Math.sqrt(distance_to_mouse_squared),
        };
      }
      vertex.hovered = false;
    }
  }
}

export function bounding_boxes_intersect(box_a, box_b) {
  // Check for overlap along the x-axis
  if (box_a.right < box_b.left || box_a.left > box_b.right) {
    return false; // No overlap on the x-axis
  }

  // Check for overlap along the y-axis
  if (box_a.bottom < box_b.top || box_a.top > box_b.bottom) {
    return false; // No overlap on the y-axis
  }

  // Overlaps on both axes, therefore the bounding boxes intersect
  return true;
}

function handle_intersection(
  globals,
  this_shape,
  other_shape,
  intersecting_points,
  intersecting_edges,
) {
  //First are going to go through all vertices of this_shape and see if they intersect other_shape
  for (let k = 0; k < this_shape.surface_vertice_holder.length; k++) {
    const vertex = this_shape.surface_vertice_holder[k];
    if (
      vertex.x < other_shape.bounding_box.right &&
      vertex.x > other_shape.bounding_box.left &&
      vertex.y < other_shape.bounding_box.bottom &&
      vertex.y > other_shape.bounding_box.top
    ) {
      //this_shape's point is inside other_shape's bounding box
      let is_inside = point_in_polygon(vertex, other_shape);

      if (is_inside) {
        this_shape.bounding_box.intersecting = true;
        other_shape.bounding_box.intersecting = true;
        const nearest_edgeasd = closest_edge(globals, vertex, other_shape);
        const nearest_edges = top_two_closest_edges(
          globals,
          vertex,
          other_shape,
        );

        const nearest_edge = nearest_edges[0];
        const second_nearest_edge = nearest_edges[1];
        //console.log("nearest_edges:", nearest_edges)

        let chosen_edge = nearest_edge;

        if (vertex.corner && false) {
          /*

                    console.log("I am corner colliding")
                    let store_vertex_x = vertex.x;
                    let store_vertex_y = vertex.y;

                    let store_edge_a_x = nearest_edge.a.x;
                    let store_edge_a_y = nearest_edge.a.y;

                    let store_edge_b_x = nearest_edge.b.x;
                    let store_edge_b_y = nearest_edge.b.x;

                    resolve_collision(globals, vertex, nearest_edge)

                    let edge_behind = {
                        a: this_shape.surface_vertice_holder[ mod((k - 1), this_shape.surface_vertice_holder.length) ],
                        b: this_shape.surface_vertice_holder[k],
                        midpoint: null,
                    }
                    edge_behind.midpoint = {
                        x: (edge_behind.a.x+edge_behind.b.x)/2,
                        y: (edge_behind.a.y+edge_behind.b.y)/2,
                    }

                    let edge_ahead = {
                        a: this_shape.surface_vertice_holder[k],
                        b: this_shape.surface_vertice_holder[(k + 1) % this_shape.surface_vertice_holder.length],
                        midpoint: null,
                    }
                    edge_ahead.midpoint = {
                        x: (edge_ahead.a.x+edge_ahead.b.x)/2,
                        y: (edge_ahead.a.y+edge_ahead.b.y)/2,
                    }

                    let edge_behind_penetration_depth = 0
                    if ( point_in_polygon(edge_behind.midpoint, other_shape) ) {
                        let closest_edge_with_depth_packet = closest_edge_with_depth(globals, edge_behind.midpoint, other_shape);
                        edge_behind_penetration_depth = closest_edge_with_depth_packet[1];
                    }
                    let edge_ahead_penetration_depth = 0
                    if ( point_in_polygon(edge_ahead.midpoint, other_shape) ) {
                        let closest_edge_with_depth_packet = closest_edge_with_depth(globals, edge_ahead.midpoint, other_shape);
                        edge_ahead_penetration_depth = closest_edge_with_depth_packet[1];
                    }
                    const first_option_total_penetration_depth = edge_behind_penetration_depth + edge_ahead_penetration_depth;
                    console.log("first_option_total_penetration_depth:", first_option_total_penetration_depth)


                    vertex.x = store_vertex_x;
                    vertex.y = store_vertex_y;

                    nearest_edge.a.x = store_edge_a_x;
                    nearest_edge.a.y = store_edge_a_y;

                    nearest_edge.b.x = store_edge_b_x;
                    nearest_edge.b.x = store_edge_b_y;





                    store_vertex_x = vertex.x;
                    store_vertex_y = vertex.y;

                    store_edge_a_x = second_nearest_edge.a.x;
                    store_edge_a_y = second_nearest_edge.a.y;

                    store_edge_b_x = second_nearest_edge.b.x;
                    store_edge_b_y = second_nearest_edge.b.x;

                    resolve_collision(globals, vertex, second_nearest_edge)

                    edge_behind = {
                        a: this_shape.surface_vertice_holder[ mod((k - 1), this_shape.surface_vertice_holder.length) ],
                        b: this_shape.surface_vertice_holder[k],
                        midpoint: null,
                    }
                    edge_behind.midpoint = {
                        x: (edge_behind.a.x+edge_behind.b.x)/2,
                        y: (edge_behind.a.y+edge_behind.b.y)/2,
                    }

                    edge_ahead = {
                        a: this_shape.surface_vertice_holder[k],
                        b: this_shape.surface_vertice_holder[(k + 1) % this_shape.surface_vertice_holder.length],
                        midpoint: null,
                    }
                    edge_ahead.midpoint = {
                        x: (edge_ahead.a.x+edge_ahead.b.x)/2,
                        y: (edge_ahead.a.y+edge_ahead.b.y)/2,
                    }

                    edge_behind_penetration_depth = 0
                    if ( point_in_polygon(edge_behind.midpoint, other_shape) ) {
                        let closest_edge_with_depth_packet = closest_edge_with_depth(globals, edge_behind.midpoint, other_shape);
                        edge_behind_penetration_depth = closest_edge_with_depth_packet[1];
                    }
                    edge_ahead_penetration_depth = 0
                    if ( point_in_polygon(edge_ahead.midpoint, other_shape) ) {
                        let closest_edge_with_depth_packet = closest_edge_with_depth(globals, edge_ahead.midpoint, other_shape);
                        edge_ahead_penetration_depth = closest_edge_with_depth_packet[1];
                    }
                    const second_option_total_penetration_depth = edge_behind_penetration_depth + edge_ahead_penetration_depth;
                    console.log("second_option_total_penetration_depth:", second_option_total_penetration_depth)


                    vertex.x = store_vertex_x;
                    vertex.y = store_vertex_y;

                    second_nearest_edge.a.x = store_edge_a_x;
                    second_nearest_edge.a.y = store_edge_a_y;

                    second_nearest_edge.b.x = store_edge_b_x;
                    second_nearest_edge.b.x = store_edge_b_y;

                    if (second_option_total_penetration_depth < first_option_total_penetration_depth) {
                        chosen_edge = second_nearest_edge;
                    }
                    */
        }

        resolve_collision(globals, vertex, chosen_edge);
        intersecting_points.push(vertex);
        intersecting_edges.push(chosen_edge);

        //const nearest_edges = edges_sorted_by_proximity(globals, vertex, other_shape);

        /*
                for (let i = 0; i < nearest_edges.length; i++) {
                    const edge_packet = nearest_edges[i];
                    const distance = edge_packet[0];
                    const edge = edge_packet[1];
                    //console.log("nearest_edges:", nearest_edges)
                    //console.log("edge:", edge)
                    //console.log("nearest_edge:", nearest_edge)

                    if (vertex.corner) {
                        console.log("I am corner colliding")
                        const store_vertex_x = vertex.x;
                        const store_vertex_y = vertex.y;

                        const store_edge_a_x = edge.a.x;
                        const store_edge_a_y = edge.a.y;

                        const store_edge_b_x = edge.b.x;
                        const store_edge_b_y = edge.b.x;

                        //I want to get the two adjacent edges


                        resolve_collision(globals, vertex, nearest_edge)

                        const edge_behind = {
                            a: this_shape.surface_vertice_holder[ mod((k - 1), this_shape.surface_vertice_holder.length) ],
                            b: this_shape.surface_vertice_holder[k],
                            midpoint: null,
                        }
                        edge_behind.midpoint = {
                            x: (edge_behind.a.x+edge_behind.b.x)/2,
                            y: (edge_behind.a.y+edge_behind.b.y)/2,
                        }

                        const edge_ahead = {
                            a: this_shape.surface_vertice_holder[k],
                            b: this_shape.surface_vertice_holder[(k + 1) % this_shape.surface_vertice_holder.length],
                            midpoint: null,
                        }
                        edge_ahead.midpoint = {
                            x: (edge_ahead.a.x+edge_ahead.b.x)/2,
                            y: (edge_ahead.a.y+edge_ahead.b.y)/2,
                        }



                        //Check for intersecting edges
                        //is edge_behind.midpoint intersecting other_shape?
                        let edge_behind_midpoint_is_inside = point_in_polygon(edge_behind.midpoint, other_shape);
                        //is edge_ahead.midpoint intersecting other_shape?
                        let edge_ahead_midpoint_is_inside = point_in_polygon(edge_ahead.midpoint, other_shape);

                        if (edge_behind_midpoint_is_inside) {
                            //console.log("edge_behind_midpoint_is_inside")
                            intersecting_points.push(edge_behind.midpoint)
                        }
                        if (edge_ahead_midpoint_is_inside) {
                            //console.log("edge_ahead_midpoint_is_inside")
                            intersecting_points.push(edge_ahead.midpoint)
                        }

                        //I want to check if the adjacent edges' center points are in the polygon, and if so by how much
                        if (false) {
                            vertex.x = store_vertex_x;
                            vertex.y = store_vertex_y;

                            edge.a.x = store_edge_a_x;
                            edge.a.y = store_edge_a_y;

                            edge.b.x = store_edge_b_x;
                            edge.b.x = store_edge_b_y;
                        } else {
                            intersecting_points.push(vertex)
                            intersecting_edges.push(edge)
                            break
                        }
                    } else {
                        resolve_collision(globals, vertex, nearest_edge)
                    }

                }
                // */
      }
    }
  }
}

export function updatePhysics(globals, constants, dt) {
  globals.imaginary_points = [];
  globals.raycast_line_segments = [];
  globals.edge_normals = [];

  // Find if a vertex is hovered
  find_closest_vertex(globals);
  if (
    globals.closest_vertex.vertex != null &&
    globals.closest_vertex.distance < globals.drag_snap_distance
  ) {
    globals.closest_vertex.vertex.hovered = true;
    if (globals.drag_mode) {
      if (!globals.still_dragging) {
        globals.closest_vertex.vertex.grabbed = true;
        globals.still_dragging = true;
      }
    } else {
      globals.closest_vertex.vertex.grabbed = false;
    }
  }

  for (let shape of globals.shapes_holder) {
    shape.update_vertices(globals, constants, dt);
  }
  for (let shape of globals.shapes_holder) {
    shape.update_springs(globals, constants);
  }

  for (let shape of globals.shapes_holder) {
    shape.update_frame_transform();
    shape.update_frame_springs(constants);
  }

  for (let shape of globals.shapes_holder) {
    shape.update_bounding_box();
    shape.bounding_box.intersecting = false;
    shape.bounding_box.intersecting_shapes_list = [];
  }

  var test_point = {
    x: 1,
    y: 1,
  };
  var test_edge = {
    a: {
      x: 0,
      y: 0,
    },
    b: {
      x: 2,
      y: 3,
    },
  };

  var intersecting_points = [];
  var intersecting_edges = [];

  globals.debug_graphics_layer_1.clear(); // Clear previous debug drawings
  globals.debug_graphics_layer_2.clear(); // Clear previous debug drawings
  globals.debug_graphics_layer_3.clear(); // Clear previous debug drawings

  for (let i = 0; i < globals.shapes_holder.length; i++) {
    var shape_a = globals.shapes_holder[i];
    for (let j = i + 1; j < globals.shapes_holder.length; j++) {
      var shape_b = globals.shapes_holder[j];
      if (
        bounding_boxes_intersect(shape_a.bounding_box, shape_b.bounding_box)
      ) {
        handle_intersection(
          globals,
          shape_a,
          shape_b,
          intersecting_points,
          intersecting_edges,
        );
        handle_intersection(
          globals,
          shape_b,
          shape_a,
          intersecting_points,
          intersecting_edges,
        );

        /*
                //next we are going to go through all vertices of shape_b and see if they intersect shape_a
                for (let vertex of shape_b.surface_vertice_holder ) {
                    if (vertex.x < shape_a.bounding_box.right && vertex.x > shape_a.bounding_box.left && vertex.y < shape_a.bounding_box.bottom && vertex.y > shape_a.bounding_box.top) {
                        //shape_b's point is inside shape_a's bounding box
                        let is_inside = point_in_polygon(vertex, shape_a);

                        if (is_inside) {
                            shape_a.bounding_box.intersecting = true;
                            shape_b.bounding_box.intersecting = true;
                            const nearest_edge = closest_edge(globals, vertex, shape_a);

                            if (nearest_edge != null) {
                                //console.log("nearest_edge:", nearest_edge)
                                resolve_collision(globals, vertex, nearest_edge)

                                intersecting_points.push(vertex)
                                intersecting_edges.push(nearest_edge)

                            }
                        }
                    }
                }
                //    */
        /*
                //Next we are going to go through all edge mid points of shape_a and see if they intersect shape_b
                for (let i = 0; i < shape_a.surface_vertice_holder.length; i++) {
                    const edge_point_a = shape_a.surface_vertice_holder[i];
                    const edge_point_b = shape_a.surface_vertice_holder[(i + 1) % shape_a.surface_vertice_holder.length];

                    const edge_centerpoint = {
                        x: (edge_point_a.x + edge_point_b.x)/2,
                        y: (edge_point_a.y + edge_point_b.y)/2,
                    }

                    if (edge_centerpoint.x < shape_b.bounding_box.right && edge_centerpoint.x > shape_b.bounding_box.left && edge_centerpoint.y < shape_b.bounding_box.bottom && edge_centerpoint.y > shape_b.bounding_box.top) {
                        //shape_a's edge_centerpoint is inside shape_b's bounding box
                        const is_inside = point_in_polygon(edge_centerpoint, shape_b);

                        if (is_inside) {
                            shape_a.bounding_box.intersecting = true;
                            shape_b.bounding_box.intersecting = true;

                            const nearest_edge = closest_edge(globals, edge_centerpoint, shape_b);

                            if (point_in_polygon(edge_point_a, shape_b)) {
                                //const nearest_edge = closest_edge(globals, edge_point_a, shape_b);
                                if (nearest_edge != null) {

                                    resolve_collision(globals, edge_point_a, nearest_edge)
                                    intersecting_edges.push(nearest_edge)
                                }
                            }

                            if (point_in_polygon(edge_point_b, shape_b)) {

                                //const nearest_edge = closest_edge(globals, edge_point_b, shape_b);
                                if (nearest_edge != null) {

                                    resolve_collision(globals, edge_point_b, nearest_edge)
                                    intersecting_edges.push(nearest_edge)
                                }
                            }

                            intersecting_points.push(edge_centerpoint)
                        }
                    }
                }

                 //Next we are going to go through all edge mid points of shape_b and see if they intersect shape_a
                 for (let i = 0; i < shape_b.surface_vertice_holder.length; i++) {
                    const edge_point_a = shape_b.surface_vertice_holder[i];
                    const edge_point_b = shape_b.surface_vertice_holder[(i + 1) % shape_b.surface_vertice_holder.length];

                    const edge_centerpoint = {
                        x: (edge_point_a.x + edge_point_b.x)/2,
                        y: (edge_point_a.y + edge_point_b.y)/2,
                    }

                    if (edge_centerpoint.x < shape_a.bounding_box.right && edge_centerpoint.x > shape_a.bounding_box.left && edge_centerpoint.y < shape_a.bounding_box.bottom && edge_centerpoint.y > shape_a.bounding_box.top) {
                        //shape_b's edge_centerpoint is inside shape_a's bounding box
                        const is_inside = point_in_polygon(edge_centerpoint, shape_a);
                        if (is_inside) {
                            shape_b.bounding_box.intersecting = true;
                            shape_a.bounding_box.intersecting = true;

                            const nearest_edge = closest_edge(globals, edge_centerpoint, shape_a);

                            if (point_in_polygon(edge_point_a, shape_a)) {
                                //const nearest_edge = closest_edge(globals, edge_point_a, shape_a);
                                if (nearest_edge != null) {

                                    resolve_collision(globals, edge_point_a, nearest_edge)
                                    intersecting_edges.push(nearest_edge)
                                }
                                intersecting_points.push(edge_point_a)
                            }

                            if (point_in_polygon(edge_point_b, shape_a)) {

                                //const nearest_edge = closest_edge(globals, edge_point_b, shape_a);
                                if (nearest_edge != null) {

                                    resolve_collision(globals, edge_point_b, nearest_edge)
                                    intersecting_edges.push(nearest_edge)
                                }
                                intersecting_points.push(edge_point_b)
                            }

                            intersecting_points.push(edge_centerpoint)
                        }
                    }
                }
                //    */
      }
    }
  }

  for (let shape of globals.shapes_holder) {
    shape.clear_touching();
  }

  for (let vertex of intersecting_points) {
    //vertex.touching = true;
  }
  for (let edge of intersecting_edges) {
    //edge.a.touching = true;
    //edge.b.touching = true;
  }
  draw_debug_points(
    globals,
    intersecting_points,
    intersecting_edges,
    globals.imaginary_points,
    globals.raycast_line_segments,
  );
}

export function make_square(globals, width) {
  var surface_vertice_list = [];
  var inner_vertice_list = [];

  var frame_vertice_list = [];
  var frame_spring_list = [];

  var spring_list = [];

  let scale = 100;
  var x = 0;
  var y = 0;

  var prev_vertex = null;
  if (width == 1) {
    for (let i = 0; i < 4; i++) {
      if (i == 0) {
        x = 0;
      } else if (i == 1) {
        x += 1;
      } else if (i == 2) {
        y += 1;
      } else if (i == 3) {
        x -= 1;
      }
      let vertex = make_vertice(scale * x, scale * y);
      surface_vertice_list.push(vertex);

      if (prev_vertex != null) {
        var spring = make_spring(vertex, prev_vertex);
        spring_list.push(spring);
      }
      prev_vertex = vertex;
    }
    surface_vertice_list[0].corner = true;
    surface_vertice_list[1].corner = true;
    surface_vertice_list[2].corner = true;
    surface_vertice_list[3].corner = true;

    spring_list.push(
      make_spring(surface_vertice_list[0], surface_vertice_list[3]),
    );

    spring_list.push(
      make_spring(surface_vertice_list[0], surface_vertice_list[2]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[1], surface_vertice_list[3]),
    );
  } else if (width == 2) {
    inner_vertice_list.push(make_vertice(scale * 1, scale * 1));
    for (let i = 0; i < 8; i++) {
      if (i < 1) {
        x = 0;
      } else if (i < 3) {
        x += 1;
      } else if (i < 5) {
        y += 1;
      } else if (i < 7) {
        x -= 1;
      } else if (i < 8) {
        y -= 1;
      }
      let vertex = make_vertice(scale * x, scale * y);
      surface_vertice_list.push(vertex);
      spring_list.push(make_spring(vertex, inner_vertice_list[0]));

      if (prev_vertex != null) {
        var spring = make_spring(vertex, prev_vertex);
        spring_list.push(spring);
      }
      prev_vertex = vertex;
    }

    surface_vertice_list[0].corner = true;
    surface_vertice_list[2].corner = true;
    surface_vertice_list[4].corner = true;
    surface_vertice_list[6].corner = true;

    spring_list.push(
      make_spring(surface_vertice_list[0], surface_vertice_list[7]),
    );

    spring_list.push(
      make_spring(surface_vertice_list[1], surface_vertice_list[7]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[1], surface_vertice_list[3]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[5], surface_vertice_list[3]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[5], surface_vertice_list[7]),
    );
  } else if (width == 3) {
    inner_vertice_list.push(make_vertice(scale * 1.5, scale * 1.5));
    for (let i = 0; i < 12; i++) {
      if (i < 1) {
        x = 0;
      } else if (i < 4) {
        x += 1;
      } else if (i < 7) {
        y += 1;
      } else if (i < 10) {
        x -= 1;
      } else if (i < 12) {
        y -= 1;
      }
      let vertex = make_vertice(scale * x, scale * y);
      surface_vertice_list.push(vertex);

      spring_list.push(make_spring(vertex, inner_vertice_list[0]));
      if (prev_vertex != null) {
        var spring = make_spring(vertex, prev_vertex);
        spring_list.push(spring);
      }
      prev_vertex = vertex;
    }

    surface_vertice_list[0].corner = true;
    surface_vertice_list[3].corner = true;
    surface_vertice_list[6].corner = true;
    surface_vertice_list[9].corner = true;

    spring_list.push(
      make_spring(surface_vertice_list[0], surface_vertice_list[11]),
    );

    spring_list.push(
      make_spring(surface_vertice_list[1], surface_vertice_list[11]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[2], surface_vertice_list[4]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[5], surface_vertice_list[7]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[8], surface_vertice_list[10]),
    );
  } else if (width == 4) {
    inner_vertice_list.push(make_vertice(scale * 1.5, scale * 1.5));
    for (let i = 0; i < 12; i++) {
      if (i < 1) {
        x = 0;
      } else if (i < 4) {
        x += 1;
      } else if (i < 7) {
        y += 1;
      } else if (i < 10) {
        x -= 1;
      } else if (i < 12) {
        y -= 1;
      }
      let vertex = make_vertice(scale * x, scale * y);
      surface_vertice_list.push(vertex);
      spring_list.push(make_spring(vertex, inner_vertice_list[0]));
      if (prev_vertex != null) {
        var spring = make_spring(vertex, prev_vertex);
        spring_list.push(spring);
      }
      prev_vertex = vertex;
    }

    spring_list.push(
      make_spring(surface_vertice_list[0], surface_vertice_list[11]),
    );

    spring_list.push(
      make_spring(surface_vertice_list[1], surface_vertice_list[11]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[2], surface_vertice_list[4]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[5], surface_vertice_list[7]),
    );
    spring_list.push(
      make_spring(surface_vertice_list[8], surface_vertice_list[10]),
    );
  }

  var shape = new Shape();
  shape.surface_vertice_holder = surface_vertice_list;
  shape.inner_vertice_holder = inner_vertice_list;
  shape.frame_vertice_holder = frame_vertice_list;
  shape.spring_holder = spring_list;
  shape.frame_spring_holder = frame_spring_list;

  globals.shapes_holder.push(shape);

  //For every surface vertex I want to make a frame vertex
  for (let surface_vertex of surface_vertice_list) {
    let frame_vertex = make_frame_vertice(
      globals,
      surface_vertex.x,
      surface_vertex.y,
    );
    frame_vertice_list.push(frame_vertex);

    var frame_spring = make_frame_spring(frame_vertex, surface_vertex);
    frame_spring_list.push(frame_spring);

    var center = shape.calculate_center();
    frame_vertex.offset_x = frame_vertex.x - center.x;
    frame_vertex.offset_y = frame_vertex.y - center.y;
  }

  shape.particle_container = new Container(256, {
    position: true,
    rotation: false,
    uvs: false,
    tint: true,
  });

  globals.app.stage.addChild(shape.particle_container);

  for (let vertex of surface_vertice_list.concat(inner_vertice_list)) {
    let particle = make_particle(globals, vertex.x, vertex.y);

    shape.particle_container.addChild(particle);
    shape.particle_holder.push(particle);
  }
}

export function make_spring(vertex_1, vertex_2) {
  var spring = {
    vertex_1: vertex_1,
    vertex_2: vertex_2,
    length: Math.sqrt(
      (vertex_2.x - vertex_1.x) ** 2 + (vertex_2.y - vertex_1.y) ** 2,
    ),
  };
  return spring;
}

export function make_frame_spring(frame_vertex, surface_vertex) {
  var spring = {
    frame_vertex: frame_vertex,
    surface_vertex: surface_vertex,
  };
  return spring;
}

export function make_vertice(x, y) {
  var vertex = {
    x: x,
    y: y,
    prev_x: x,
    prev_y: y,
    grabbed: false,
    hovered: false,
    touching: false,
    mass: 1,
    corner: false,
  };

  return vertex;
}

export function make_particle(globals, x, y) {
  const particle = new Sprite(globals.circle_texture);
  particle.anchor.set(0.5);
  particle.position.set(x, y);

  return particle;
}

export function make_frame_vertice(globals, x, y) {
  var frame_vertex = {
    x: x,
    y: y,
    offset_x: 0,
    offset_y: 0,
  };

  return frame_vertex;
}

function draw_debug_points(
  globals,
  points,
  edges,
  imaginary_points,
  raycast_line_segments,
) {
  globals.debug_graphics_layer_1.beginFill(0xff0000); // Red color

  points.forEach((point) => {
    globals.debug_graphics_layer_1.drawCircle(point.x, point.y, 5);
  });

  globals.debug_graphics_layer_1.endFill();

  globals.debug_graphics_layer_1.beginPath();
  globals.debug_graphics_layer_1.lineStyle(4, 0x00ff00);

  edges.forEach((edge) => {
    globals.debug_graphics_layer_1.moveTo(edge.a.x, edge.a.y);
    globals.debug_graphics_layer_1.lineTo(edge.b.x, edge.b.y);
  });

  globals.debug_graphics_layer_1.stroke();

  globals.debug_graphics_layer_1.beginFill(0xff00ff); // Purple color

  imaginary_points.forEach((point) => {
    globals.debug_graphics_layer_1.drawCircle(point.x, point.y, 10);
  });

  globals.debug_graphics_layer_2.endFill();

  globals.debug_graphics_layer_2.beginFill(0x0000ff); // Purple color

  raycast_line_segments.forEach((segment) => {
    const point_1 = segment[0];
    const point_2 = segment[1];

    globals.debug_graphics_layer_2.moveTo(point_1.x, point_1.y);
    globals.debug_graphics_layer_2.lineTo(point_2.x, point_2.y);
  });

  //globals.debug_graphics_layer_2.endFill();

  globals.edge_normals.forEach((normal_packet) => {
    const midpoint = normal_packet[0];
    const normal = normal_packet[1];
    const normal_endpoint = {
      x: midpoint.x + 20 * normal.x,
      y: midpoint.y + 20 * normal.y,
    };

    globals.debug_graphics_layer_2.moveTo(midpoint.x, midpoint.y);
    globals.debug_graphics_layer_2.lineTo(normal_endpoint.x, normal_endpoint.y);
  });

  globals.debug_graphics_layer_2.endFill();
}

export function setup(globals, app, width, height, pin_number) {
  width = 10;
  height = 10;

  if (globals.all_lines_graphics != undefined) {
    globals.all_lines_graphics.destroy();
  }
  if (globals.particle_container != undefined) {
    globals.particle_container.destroy();
  }
  if (globals.bounding_box_graphics != undefined) {
    globals.bounding_box_graphics.destroy();
  }

  if (globals.debug_graphics_layer_1 != undefined) {
    globals.debug_graphics_layer_1.destroy();
  }

  if (globals.debug_graphics_layer_2 != undefined) {
    globals.debug_graphics_layer_2.destroy();
  }

  if (globals.debug_graphics_layer_3 != undefined) {
    globals.debug_graphics_layer_3.destroy();
  }

  globals.vertex_holder = [];
  globals.line_holder = new Set();
  globals.particle_holder = [];
  globals.all_lines_graphics = new Graphics();
  globals.bounding_box_graphics = new Graphics();
  globals.debug_graphics_layer_1 = new Graphics();
  globals.debug_graphics_layer_2 = new Graphics();
  globals.debug_graphics_layer_3 = new Graphics();

  globals.line_length = 30;
  globals.all_lines_graphics.setStrokeStyle({ color: 0x000000, width: 1 });
  globals.bounding_box_graphics.setStrokeStyle({ color: 0x00ff00, width: 1 });
  globals.debug_graphics_layer_1.setStrokeStyle({ color: 0x00ffff, width: 1 });
  globals.debug_graphics_layer_2.setStrokeStyle({ color: 0x0000ff, width: 1 });
  globals.debug_graphics_layer_3.setStrokeStyle({ color: 0xff00ff, width: 12 });

  app.stage.addChild(globals.polygon_graphics);

  app.stage.addChild(globals.all_lines_graphics);
  app.stage.addChild(globals.bounding_box_graphics);
  app.stage.addChild(globals.debug_graphics_layer_1);
  app.stage.addChild(globals.debug_graphics_layer_2);
  app.stage.addChild(globals.debug_graphics_layer_3);

  globals.particle_container = new Container(256, {
    position: true,
    rotation: false,
    uvs: false,
    tint: true,
  });

  app.stage.addChild(globals.particle_container);

  globals.circle_texture = createCircleTexture(app, 3);

  set_render_offsets_and_scale(globals);
}

export function set_up_event_listeners(globals, elements, constants, app) {
  app.canvas.addEventListener("touchstart", (event) => {
    const touches = event.changedTouches;
    const last_touch = touches[touches.length - 1];
    globals.mouse_position = { x: last_touch.clientX, y: last_touch.clientY };
    globals.drag_mode = true;
    globals.still_dragging = false;
  });

  app.canvas.addEventListener("touchend", (event) => {
    const touches = event.changedTouches;
    const last_touch = touches[touches.length - 1];
    globals.mouse_position = { x: last_touch.clientX, y: last_touch.clientY };
    globals.drag_mode = false;
    globals.still_dragging = false;
    if (globals.chosen_dragging_vertex != null) {
      globals.chosen_dragging_vertex.grabbed = false;
    }
  });

  app.canvas.addEventListener("touchcancel", (event) => {
    const touches = event.changedTouches;
    const last_touch = touches[touches.length - 1];
    globals.mouse_position = { x: last_touch.clientX, y: last_touch.clientY };
    globals.drag_mode = false;
    globals.still_dragging = false;
    if (globals.chosen_dragging_vertex != null) {
      globals.chosen_dragging_vertex.grabbed = false;
    }
  });

  app.canvas.addEventListener("touchmove", (event) => {
    const touches = event.changedTouches;
    const last_touch = touches[touches.length - 1];
    globals.mouse_position = { x: last_touch.clientX, y: last_touch.clientY };
  });

  app.canvas.addEventListener("contextmenu", (event) => event.preventDefault());

  app.canvas.addEventListener("mousedown", (event) => {
    if (event.button == globals.primary_button) {
      globals.drag_mode = true;
      globals.still_dragging = false;
    }

    if (event.button == globals.grav_button) {
      globals.grav_modifier = 10;
    }

    if (event.button == globals.cut_button) {
      globals.cut_mode = true;
    }
  });

  window.addEventListener("resize", (event) => {
    set_render_offsets_and_scale(globals);

    if (window.innerWidth < 800) {
      globals.all_lines_graphics.setStrokeStyle({ color: 0x000000, width: 1 });
    } else {
      globals.all_lines_graphics.setStrokeStyle({
        color: 0x000000,
        width: Math.max(parseInt(globals.line_length / 8), 1),
      });
    }
  });

  app.canvas.addEventListener("mousemove", (event) => {
    globals.mouse_position = { x: event.clientX, y: event.clientY };
  });

  app.canvas.addEventListener("mouseup", (event) => {
    if (event.button == globals.primary_button) {
      globals.drag_mode = false;
      globals.still_dragging = false;
      if (globals.chosen_dragging_vertex != null) {
        globals.chosen_dragging_vertex.grabbed = false;
      }
    }

    if (event.button == globals.grav_button) {
      globals.grav_modifier = 1;
    }

    if (event.button == globals.cut_button) {
      globals.cut_mode = false;
    }
  });

  elements.build_button.onclick = function () {
    globals.edit_mode = !globals.edit_mode;
  };

  window.onkeydown = function (event) {
    if (event.key === "1") {
      make_square(globals, 1);
    }
    if (event.key === "2") {
      make_square(globals, 2);
    }
    if (event.key === "3") {
      make_square(globals, 3);
    }
  };
}

================
File: src/index.js
================
import { Application, Container, Graphics, Sprite, autoDetectRenderer } from 'pixi.js';
import { Constants, Elements, Globals, Shape } from './classes.js'
import { hide_element, show_element, updatePhysics, setup, set_up_event_listeners, create_fps_counter, make_vertice, find_closest_vertex, draw_graphics,  } from './functions.js'

const constants = new Constants();
const globals = new Globals();
const elements = new Elements();

// Create a PixiJS application.
const app = new Application();
globals.app = app;

let accumulator = 0;

// Asynchronous IIFE
(async () =>
{
    // Intialize the application.
    await app.init({
        backgroundAlpha: 0,
        resizeTo: window,
        antialias: true,
    });


    elements.cloth_sim_holder.appendChild(app.canvas);
    set_up_event_listeners(globals, elements, constants, app);

    setup(globals, app, constants.DEFAULT_COLUMNS, constants.DEFAULT_ROWS, constants.DEFAULT_PINS);
    create_fps_counter();
    var running_setup = true;

    app.ticker.add((time) =>
    {
        if (running_setup) {
				if ( document.getElementById("fps-counter-element") != undefined && document.getElementById("fps-counter-element") != null) {
					//console.log("Done")
                    elements.fps_counter = document.getElementById("fps-counter-element");
                    elements.fps_counter.classList.add('hidden');
                    running_setup = false
				}
        } else {

            if (globals.edit_mode != true ) {
                accumulator += time.deltaTime / 60; // Convert to seconds
    
                // Perform fixed time step updates
                while (accumulator >= constants.FIXED_TIME_STEP) {
                    updatePhysics(globals, constants, constants.FIXED_TIME_STEP);
                    accumulator -= constants.FIXED_TIME_STEP;
                }

            } else {

                if ( globals.closest_vertex != null) {

                }

                if ( globals.primary_button_clicked == true ) {
                    const adjusted_mouse_position = {x:globals.mouse_position.x/globals.render_scale, y: globals.mouse_position.y/globals.render_scale}
            
                    make_vertice(globals, adjusted_mouse_position.x, adjusted_mouse_position.y);
                    globals.primary_button_clicked = false;
                }

            }

            find_closest_vertex(globals);

            //console.log("globals.closest_vertex:", globals.closest_vertex)

            if ( globals.closest_vertex.vertex != null && globals.closest_vertex.distance < globals.drag_snap_distance*globals.render_scale ) {
                globals.closest_vertex.vertex.hovered = true;
            }
            draw_graphics(globals);

            
        }
    });
})();

================
File: src/styles.css
================
/*body {
    display: flex;
    flex-direction: row;
    font-family: testfont;
}


#main-view {
    width: 100%;
    height: 100%;
}

body {
    font-family: Arial, Helvetica, sans-serif;
}

*/

body {
    background: url('assets/dot-background.svg');
    overflow: clip;
    margin: 0;
    background-color: #fafafa;
    background-color: #fdfdfd;
    -webkit-user-select: none; /* Safari */
    -ms-user-select: none; /* IE 10 and IE 11 */
    user-select: none; /* Standard syntax */
}

@font-face {
    font-family: custom-heavy;
    src: url(assets/fonts/shin-go/AOTFShinGoProBold.otf);
    /*
    src: url(assets/fonts/FOT-YurukaStd-UB.otf);
    */
}

@font-face {
    font-family: custom-normal;
    src: url(assets/fonts/shin-go/AOTFShinGoProMedium.otf);
}

#menu-holder {
    position: absolute;
    z-index: 10;
    width: 300px;
    height: 350px;
    /*
    */
    right: 0px;
    top: 0px;
    display: flex;
    justify-content: flex-start;
    flex-direction: column;
    align-content: center;
    align-items: center;
    /*
    font-family: testfont;
    */
    font-family: custom-normal;
    font-size: 14px;

    /*
    */
    transition: top .15s;
}

.title-holder {
    font-family: custom-heavy;
    font-weight: bold;
    font-size: 14px;

}

.setting-row-holder {
    /*
    gap: 10px;
    border-bottom: 1px dashed;
    */
    display: flex;
    flex-direction: row;
    align-content: center;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 5px 20px;
    flex-wrap: wrap;

    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
.setting-row-holder>* {
    flex: 1 1 20px;
}

#custom-fps-holder {
    position: absolute;
    z-index: 10;
    background-color: red;
    width: 100px;
    height: 100px;
    top: 100px;
    left: 100px;
}

.svg-holder {
    color: black;
    height: 26px;
    width: 26px;
    position: absolute;
    top: 8px;
    right: 8px;
}

.button:hover {
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .1);
}

#settings-overlay {
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, .9);
    position: absolute;
    z-index: 100;
    /*

    backdrop-filter: blur(10rem);
    */
    display: flex;
    flex-direction: column;
    align-content: center;
    justify-content: center;
    align-items: center;

}

.card-material {
    background-color: #e5e7eb;
    backdrop-filter: blur(10rem);
    background: rgba(229, 231, 235, 0.1);
    background: rgba(116, 157, 199, 0.1);
    background: rgba(229, 231, 235, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.1);

    border-radius: 10px;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .1);

    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
}

.settings-holder {
    width: 400px;
    height: 400px;
    position: relative;
    display: flex;
    justify-content: flex-start;
    flex-direction: column;
    align-content: center;
    align-items: center;
    font-family: custom-normal;
}

.hidden {

    display: none !important;
}

.show-flex {
    display: flex !important;
}

#menu-toggle-button {
    width: 26px;
    height: 26px;
    padding: 4px;
    bottom: 4px !important;
    position: absolute;
    /*
    background-color: red;
    right: 0px;
    */
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    align-content: center;
    align-items: center;
    justify-content: center;
    padding: 0px;
}

@media only screen and (max-width: 600px) {

    #menu-holder {
        width: 100%;
        top: auto;
        bottom: 0px;
    }

    .hide-menu {
        top: auto !important;
        bottom: -320px !important;
    }

  }

.hide-menu {
    top: -320px !important;
}

.button {

    padding: 4px;
    border-radius: 8px;
}

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <title>Document</title>
  <style type="text/css">
    @import url(src/styles.css);
  </style>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="initial-scale=0.75">

  <script type="module" src="src/index.js"></script>


</head>
<body>
  
  <div id="menu-holder" class="card-material">
    <!---->
    <div id= "settings-open-button" class="svg-holder button">
      <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
    >
      <path
        d="M10.2007 4.11982C10.8318 3.50174 11.1473 3.1927 11.5097 3.07661C11.8285 2.97446 12.1713 2.97446 12.4902 3.07661C12.8526 3.1927 13.1681 3.50174 13.7992 4.11982L14.1026 4.417C14.3754 4.68424 14.5118 4.81786 14.6701 4.91393C14.8104 4.99913 14.963 5.06232 15.1225 5.1013C15.3023 5.14527 15.4932 5.14725 15.8751 5.15122L16.2998 5.15562C17.1831 5.16479 17.6247 5.16937 17.9631 5.34354C18.2608 5.49678 18.5032 5.73918 18.6564 6.03688C18.8306 6.37522 18.8351 6.81685 18.8443 7.70012L18.8487 8.12481C18.8527 8.5067 18.8547 8.69764 18.8986 8.87749C18.9376 9.03695 19.0008 9.18951 19.086 9.32984C19.1821 9.48809 19.3157 9.62451 19.5829 9.89735L19.8801 10.2008C20.4982 10.8318 20.8072 11.1473 20.9233 11.5097C21.0255 11.8286 21.0255 12.1714 20.9233 12.4903C20.8072 12.8527 20.4982 13.1682 19.8801 13.7992L19.5829 14.1026C19.3157 14.3755 19.1821 14.5119 19.086 14.6702C19.0008 14.8105 18.9376 14.963 18.8986 15.1225C18.8547 15.3024 18.8527 15.4933 18.8487 15.8752L18.8443 16.2999C18.8351 17.1831 18.8306 17.6248 18.6564 17.9631C18.5032 18.2608 18.2608 18.5032 17.9631 18.6565C17.6247 18.8306 17.1831 18.8352 16.2998 18.8444L15.8751 18.8488C15.4932 18.8527 15.3023 18.8547 15.1225 18.8987C14.963 18.9377 14.8104 19.0009 14.6701 19.0861C14.5118 19.1821 14.3754 19.3158 14.1026 19.583L13.7992 19.8802C13.1681 20.4983 12.8526 20.8073 12.4902 20.9234C12.1713 21.0255 11.8285 21.0255 11.5097 20.9234C11.1473 20.8073 10.8318 20.4983 10.2007 19.8802L9.89729 19.583C9.62445 19.3158 9.48803 19.1821 9.32978 19.0861C9.18945 19.0009 9.03689 18.9377 8.87742 18.8987C8.69758 18.8547 8.50664 18.8527 8.12475 18.8488L7.70006 18.8444C6.81679 18.8352 6.37516 18.8306 6.03682 18.6565C5.73912 18.5032 5.49672 18.2608 5.34348 17.9631C5.16931 17.6248 5.16473 17.1831 5.15556 16.2999L5.15115 15.8752C5.14719 15.4933 5.14521 15.3024 5.10124 15.1225C5.06226 14.963 4.99907 14.8105 4.91387 14.6702C4.81779 14.5119 4.68418 14.3755 4.41694 14.1026L4.11976 13.7992C3.50168 13.1682 3.19264 12.8527 3.07655 12.4903C2.9744 12.1714 2.9744 11.8286 3.07655 11.5097C3.19264 11.1473 3.50168 10.8318 4.11976 10.2008L4.41694 9.89735C4.68418 9.62451 4.81779 9.48809 4.91387 9.32984C4.99907 9.18951 5.06226 9.03695 5.10124 8.87749C5.14521 8.69764 5.14719 8.5067 5.15115 8.12481L5.15556 7.70012C5.16473 6.81685 5.16931 6.37522 5.34348 6.03688C5.49672 5.73918 5.73912 5.49678 6.03682 5.34354C6.37516 5.16937 6.81679 5.16479 7.70006 5.15562L8.12475 5.15122C8.50664 5.14725 8.69758 5.14527 8.87742 5.1013C9.03689 5.06232 9.18945 4.99913 9.32978 4.91393C9.48803 4.81786 9.62445 4.68424 9.89729 4.417L10.2007 4.11982Z"
        stroke="currentcolor"
        stroke-width="1.4"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
      <path
        d="M10.991 12C10.991 11.4477 11.4479 11 12.0001 11C12.5524 11 13.0093 11.4477 13.0093 12C13.0093 12.5523 12.5524 13 12.0001 13C11.4479 13 10.991 12.5523 10.991 12Z"
        stroke="currentcolor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      />
    </svg>
    </div>

    <div class="title-holder">
      <h1>Menu</h1>
    </div>

    <div class="setting-row-holder">
      <button id="build-button">Build</button>
    </div>

    <div id="menu-toggle-button" class="button">
      <svg id="down-arrow" class="hidden"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
      >
        <path
          d="M6 9C7.57701 11.1808 9.42293 13.1364 11.4899 14.8172C11.7897 15.0609 12.2103 15.0609 12.5101 14.8172C14.5771 13.1364 16.423 11.1808 18 9"
          stroke="currentcolor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </svg>
      <svg id="up-arrow"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
      >
        <path
          d="M6 15C7.57701 12.8192 9.42293 10.8636 11.4899 9.18284C11.7897 8.93905 12.2103 8.93905 12.5101 9.18284C14.5771 10.8636 16.423 12.8192 18 15"
          stroke="currentcolor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
      </svg>
    </div>
  </div>
  
  <div id="cloth-sim-holder">

  </div>
</body>
</html>

================
File: package.json
================
{
  "dependencies": {
    "@lancercomet/fps-counter": "^1.0.0",
    "pixi.js": "^8.3.4",
    "stats.js": "^0.17.0"
  }
}

================
File: README.md
================
# soft-body-sim
